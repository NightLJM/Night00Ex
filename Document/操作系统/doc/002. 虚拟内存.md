## **002.虚拟内存**

### **1 基本概念**

1. 如果处理器访问一个不存在于内存中的虚拟地址，就会产生一个中断。操作系统会将中断的进程置于阻塞的状态，并取得控制。为了继续执行该进程，操作系统会产生一个磁盘IO读请求，将缺少的逻辑地址对应的进程快放进内存，在执行磁盘IO期间，操作系统可以调度另一个进程执行。一旦需要的块被放进内存，则产生一个IO中断，控制被交回操作系统，而操作系统将由于缺少该块而被阻塞的进程置为就绪状态。
2. 基于分页的虚拟内存--页表：
    1. 虚拟地址：页号 + 偏移量
    2. 页号：页表项的索引
    3. 页框号：对应内存中的位置
    4. P位：指示对应页是否装入内存
    5. M位：指示从该页装入内存到现在，是否修改过。如果修改过，该页换出的时候，需要写磁盘。
    6. 一般来说，页号域的长度大于页框域。
3. 分页式虚拟内存：
    1. 一级分页的情况：假设32位地址的方案，采用字节级寻址，页尺寸为4KB(2<sup>12</sup>的字节)，页表项大小为4字节。那么采用1级分页的话，就需要2<sup>20</sup>个页表项，页表大小为 4字节 * 2<sup>20</sup> = 4MB (2<sup>22</sup>字节)
    2. 二级分页的情况：假设32位地址的方案，采用字节级寻址，页尺寸为4KB(2<sup>12</sup>的字节)，页表项大小为4字节。那么采用2级分页的话，第一级根页表有2<sup>10</sup>个页表项，一级根页表大小4KB(2<sup>10</sup>字节)；第二级页表有2<sup>10</sup>个，每个页表有2<sup>10</sup>个页表项，一个二级页表大小4KB(2<sup>10</sup>字节)。
    3. 一般一级页表放内存，二级页表放磁盘，当通过一级页表访问二级页表发生缺页时，才将缺的页换入内存。
3. TLB：转换检测缓冲区，是个高速缓存，比内存快。用于存放最近访问的页表项：      
![TLB相关操作][1]
4. 分段式虚拟内存：和简单分段类似，不过这里得考虑段不在内存的情况。     
![分段式][2]
5. 段页式：将分段和分页式结合。逻辑地址由段基址和段偏移量组成，段偏移量又可以看做是段中的页号和页偏移量组成。    
![段页式][3]
6. 在段页式虚拟内存中，每个进程使用一个段表和一些页表。每个进程段使用一个页表。
7. 内存置换策略：
    1. LRU：最近最少使用；
    2. FIFO：先进先出；
    3. 时钟：超过一定时长没使用的页被换出。







[1]: ./../resource/002-1.TLB相关操作.jpg
[2]: ./../resource/002-2.分段式.jpg
[3]: ./../resource/002-3.段页式.jpg