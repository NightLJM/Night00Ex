## **001. 进程几种通讯的比较**

进程通信的方式主要有：管道、FIFO、信号量、消息队列、共享内存和套接字。

1. 管道是一种只能用在共同祖先的进程之间的通信方式，然后根据它数据的流动方向又分为半双工和全双工的。有的系统可能并不会实现全双工的管道，因此，如果要考虑程序在不同的系统的一致性的话，应当按照半双工来使用管道。管道使用的流程一般是：父进程先创建管道，然后fork子进程，然后父进程分别关闭管道没有使用的一端。另外，如果子进程的标准输入和标准输出均来自父进程，那子进程就是父进程的协程。
2. FIFO又称为命名管道，它没有管道的那种共同祖先的限制。就理解来说的话，可以把FIFO理解成用于两个进程之间沟通的文件，除了创建，读写的流程基本都一样。但与普通文件不同的是，数据通过FIFO的时候都是走内存的，普通文件的话可能是设计磁盘操作。而且FIFO还有一些用于通信的特征：比如只有写进程没有读进程的话会产生SIGPIPE的信号。
3. 信号量、消息队列、共享内存又分为SystemV和Posix两套。SystemV的用起来比较麻烦，Posix的用起来方便些。信号量可以理解为资源的数量，也算一种同步机制，初始化的时候会给它赋这么一个初始值。当某个进程获取这个信号量的时候，如果这个信号量的值大于0，那就可以获取成功，并且这个值减1。如果等于0的话，就根据进程是直接wait还是trywait或者是timedwait来有不同的行为，总之就是资源没获取成功。进程释放资源的时候这个资源数就会加一。Posix信号量有一个引用计数，如果要删除这个信号量的话，这个信号量会一直存在到最后一个进程不使用它。
4. 消息队列其实就是消息的链表。这个链表的节点有两个内容，消息类型和具体的数据。进程放数据的话就直接往里面塞，拿数据的话，可以拿队列的第一个，也可以拿某种类型的数据的第一个，也可以拿类型小于某个值的第一个。这里的类型是一个长整型。
5. 共享内存就是把同一块内存区域映射到不同进程的地址空间。因为是同一块空间，也就设计到同步问题，一般和其他用于同步的技术一起使用，如信号量之类的。
6. 最后是套接字，因为它支持不同机器间的通信，因此基本上都用在网络编程中。
7. 这些通信方式里面最快的就是共享内存。

## **002. malloc和new的细节**

1. 首先malloc和new分别是C和C++里面的函数，它们都被用来分配堆上的内。
2. 先说malloc吧：
    1. 使用malloc的时候告诉它一个，它返回一个指向堆上空间的指针，这个空间的大小就是传进的字节数。如果分配失败的话，它直接返回空指针。刚分配还没使用的话，malloc只是要了一块虚拟内存的空间，这时候还没映射到物理内存，当实际使用的时候，会触发缺页，然后映射到物理内存。
    2. malloc返回的的指针是个空指针类型，也就是说不涉及到数据类型，因此真正使用的时候要将这个指针转一遍。而且，malloc分配的内存不涉及到对象的初始化，要初始化对象的话，用calloc，要重新指定一个已经分配的内存的大小的话用realloc。
    3. malloc和free配套使用。
3. 然后是new：
    1. new传入的是类构造函数指定的参数，然后它返回一个这个对象的指针，这个对象也是堆上的。如果new失败的话，会抛bad_alloc的异常。
    2. new因为返回的是对象的指针，因此涉及到两步。第一步是调用operate new，operate new是C++的一个函数，可以重载，我们说的new是一个操作符，没有重载的说法。但是，operate new太底层了，很少有重载的需求。new的第二步就是调用对象的构造函数初始化对象。
    3. new和delete配套使用，如果new返回的是一个数组指针的话，delete也要用方括号的那种形式，因为malloc是直接返回原生空指针，所以也就没这说法。

## **003. 父进程使用malloc得到一块内存，子进程可以使用吗**

1. 首先父进程malloc了一块内存，子进程中相应的也有一块内存，刚fork的时候，这两个内存是一样的，但只要有一个进程往这个内存里写数据，它们的物理内存就会不同。具体的原因得看fork的机制：
    1. 父进程fork子进程的时候，子进程会从父进程那里复制一份页表。也就是说，这个时候父子进程有一样的数据段、代码段和堆栈段，虚拟地址是一样的，虚拟地址映射的物理地址也是一样的。
    2. 因为父子进程共享了物理页面，因此内核会把它标记成已读，这个时候父子进程都无法对它修改，要是修改的话，就会产生一个错误，然后内核给这个进程这次修改的页映射一个新的物理页，这也就是写时复制技术。之所以有这个技术还是因为fork后经常接exec，exec会清除原有的堆栈和父进程共享空间，为了效率考虑。
    3. 所以，当实际往这块内存写的时候，物理地址会变成两块。





