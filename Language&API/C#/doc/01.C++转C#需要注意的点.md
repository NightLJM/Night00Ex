## **001.C++转C#需要注意的点**

1. C#中常见的基础数据类型为值类型(int, float等), struct也是值类型; string、class是引用类型。string虽然是引用类型，但有个类似写时复制的特性，具体表现如下列代码所示。
``` C#
    string s1 = new string("Value is s1");
    string s2 = s1;
    Console.WriteLine(s1);      // "Value is s1"
    Console.WriteLine(s2);      // "Value is s1"
    Console.WriteLine("s1 hashCode: {0}; s2 hashCode: {1}", s1.GetHashCode(), s2.GetHashCode());    //s1和s2的hash值是一样的
    s1 = "Value is ss1";
    Console.WriteLine(s1);      // Value is ss1
    Console.WriteLine(s2);      // "Value is s1"
    Console.WriteLine("s1 hashCode: {0}; s2 hashCode: {1}", s1.GetHashCode(), s2.GetHashCode());    //s1和s2的hash值不一样；且s1的hashcode变了
```

2. C#的函数重载也和C++有点不同。C#里基类函数一定要用virtual关键字声明，子类重载函数一定要用override声明；若子类没用override声明，则是覆盖而不是重载。另外，C#只允许继承一个父类，不允许多重继承。
``` C#
    class BaseClass
    {
        public virtual void testFun()
        {
            Console.WriteLine("This is Base Class!");
        }
    }
    class DerivedClass : TestClass
    {
        public override void testFun()
        {
            Console.WriteLine("This is Derived Class!");
        }
    }

    class DerivedClass1 : DerivedClass
    {
        public override void testFun()
        {
            Console.WriteLine("This is Derived Class1!");
        }
    }
    class Test
    {
        public static void Main(string[] args)
        {
            TestClass c1 = new TestClass();
            TestClass c2 = new DerivedClass();
            TestClass c3 = new DerivedClass1();
            c1.testFun();       // This is Base Class!
            c2.testFun();       // This is Derived Class!
            c3.testFun();       // This is Derived Class!
        }
    }
```

3. interface只负责声明成员和函数，具体性质(是否是virtual等)则根据子类的实现看。
``` C#
    interface TestInterface
    {
        int a { get; set; }
        int b { get; set; }
        void fun();
    }

    class TestClass : TestInterface
    {
        public int a { get; set; }
        public int b { get; set; }

        public virtual void fun()
        {
            Console.WriteLine("This is Class fun");
        }
    }

    class TestClass1 : TestClass
    {
        public override void fun()
        {
            Console.WriteLine("This is Class1 fun");
        }
    }

    class TestClass2 : TestInterface
    {
        public int a { get; set; }
        public int b { get; set; }
        public virtual void fun()
        {
            Console.WriteLine("This is Class2 fun");
        }
    }

    class TestClass3 : TestClass
    {
        public virtual void fun()       //其实是覆盖
        {   
            Console.WriteLine("This is Class3 fun");
        }
    }

    class MainClass
    {
        public static void Main(string[] args)
        {
            TestInterface c1 = new TestClass();
            TestInterface c2 = new TestClass1();
            TestInterface c3 = new TestClass2();
            TestInterface c4 = new TestClass3();
            c1.fun();   //This is Class fun
            c2.fun();   //This is Class1 fun
            c3.fun();   //This is Class2 fun
            c4.fun();   //This is Class fun
        }
    }
```

4. 字符串插值比+运算符的效率要高。
``` C#
    string s1 = "This is " + userName.Text;
    string s2 = $"This is {userName.Text}";  //建议用这种拼接方式

    int a = 1, b = 2;
    string s3 = $"{a} + {b}";  //s3为：1 + 2
```

5. 函数简化。
``` C#
    public static int fun1(int a, int b)
    {
        return a + b;
    }

    public static void fun2()
    {
        Console.WriteLine();
    }

    public static int simpleFun1(int a, int b) => a + b;      //与fun1等价

    public static int simpleFun2() => Console.WriteLine();    //与fun2等价
```

 6. 函数返回值为元组。
 ``` C#
    public static (int, int) fun()
    {
        return (1, 2);
    }
 ```

 7. 函数传递具名参数。

  ``` C#
    public static void fun(int a, int b = 1, int c = 2)
    {

    }

    fun(third : 1, first : 2, second : 3);      // c = 1, a = 2, b =3
    fun(third : 1, first : 2);                  // c = 1, a =2, b = default
 ```