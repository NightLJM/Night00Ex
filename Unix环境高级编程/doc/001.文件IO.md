## **001.文件IO**

### **1.1 基本函数**

1.文件描述符：当打开或创建文件时，内核向进程返回文件描述符。0是标准输入，1是标准输出，2是标准错误。  

2.打开文件：open(const char* path, int oflag, ...)和openat(int fd, const char* path, int oflag, ...)
  1. path参数为绝对路径时，fd可忽略，这是open和openat同   
  2. path为相对路径时，fd代表相对路径名在文件系统的地址，通过打开其目录获取    
  3. path为相对路径，fd指定特殊值AT_FDCWD，这是相对路径名为当前工作目录    

3.关闭文件：close(int fd)
  1. 关闭一个文件会释放该进程加在该文件上的所有记录锁    
  2. 进程终止时，内核会关闭它打开的所有文件

4.函数sleek：off_t lseek(int fd, off_t offset, int whence)
  1. whence == SEEK_SET, 偏移量从文件开始处算
  2. whence == SEEK_CUR, 偏移量当前偏移量开始算，偏移量可正可负   
  3. whence == SEEK_END, 偏移量从末尾处开始算，偏移量可正可负  
  4. 此函数可用来查看文件能否设置偏移量，对管道、FIFO、网络套接字返回-1   
  5. 文件偏移量可以大于当前文件长度，这种情况下，对文件的下次写将加长该文件，在文件中形成空洞，没写过的字节被读为0.   
  6. 空洞也占文件大小，测试代码在[这里][1]

5.函数read: ssize_t read(int fd, void *buf, size_t nbytes)
  1. 若read成功，返回read到的字节数，若出错，返回-1
  2. 若到达文件尾端，返回0；例如，离文件末尾有30个字节，而要求读100字节，那么调用read返回30,再调用read返回0。
  3. 从网络读时，网络的缓冲机制可能导致读到的字节比要求的少
  4. 从管道或FIFO读时，若管道包含的字节少于所需的数量，则read只返回实际可用的字节数
  5. 从面向记录的设备（如磁带）中读，一次最多返回一条记录

6.函数write: ssize_t write(int fd, void *buf, size_t nbytes)
  1. 返回值一般与nbytes相同，否则表示出错

### **1.2 文件共享**






## **EX.问题**
1.lseek通过返回值是否为-1来判断能不能lseek，万一偏移量时-1咋办?





[1]: ./../code/001.文件IO/1.sleekTest.cpp