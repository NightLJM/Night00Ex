## **008.线程**

**8.1 概念**

1. 即使程序运行在但处理器上，也能得到多线程编程的好处。因为当多线程程序在某些串行化任务中不得不阻塞时，由于还有另一些线程还能运行，所以多线程程序在单处理器上还是能改善响应时间和吞吐量。
2. 每个线程包含有表示执行环境所必须的信息：线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量、线程私有数据。
3. 一个线程的所有信息对进程中的所有线程都是共享的，包括可执行程序的代码、程序的全局内存、堆内存、栈和文件描述符。

**8.2 线程标识**

``` C
int pthread_equal(pthread_t tid1, pthread_t tid2);
pthread_t pthread_self(void);
```

1. 线程ID在进程上下文内才有意义；进程ID则是在整个系统中是唯一的。
2. 为了可移植性，线程id不能用一个整数类型来表示，而是使用pthread_t，因此同样提供了pthread_equal函数来比较两线程id是否相同。
3. pthread_equal返回值：若相等，返回非0数值；若不相等，返回0。
4. pthread_self返回调用线程的线程id。

**8.3 线程创建**

``` C
int pthread_create(pthread_t* restrict tidp, const pthread_attr_t* restrict attr,
        void* (*start_rtn)(void*), void* restrict arg);
```
1. 返回值：若成功，返回0；否则，返回错误编号。
2. 参数说明：
    1. tidp：若创建成功，此结构体指针指向创建好的线程id
    2. start_rtn：新线程开始执行的地址。
    3. arg：若start_rtn需要传入参数，则通过这个传入。
3. 线程创建时，不能保证哪个线程先运行：是新创建的线程，还是调用线程。这取决于调度算法。新线程可能在pthread_create返回前就开始执行。
4. 新创建的线程可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但该线程的挂起信号集会被清除。
5. pthread函数在调用失败时会返回错误吗，它们不像其他POSIX函数一样设置errno。每个线程都有个errno的副本。这只是为了和现有使用errno的函数兼容。

**8.4 线程终止**

**1) 线程退出方式**

1. 如果进程中任意线程调用了exit、_Exit、或者_exit，那整个进程就会终止。类似，如果默认动作是终止进程，那么发送到线程的信号就会终止整个进程。
2. 单个线程可以通过三种方式退出：
    1. 线程简单地从启动例程返回，返回值就是线程的退出码。
    2. 线程可以被同一进程的其他线程取消。
    3. 线程调用pthread_exit。

**2) pthread_exit和pthread_join**

``` C
void pthread_exit(void* rval_ptr);
int pthread_join(pthread_t thread, void** rval_ptr);
```
1. pthread_exit用于退出一个线程，rval_ptr指正与pthread_create中start_rtn的返回值类似，用于传给其他线程。
2. pthread_join函数用于等待指定线程结束，并获取指定线程的返回值，rval_ptr置为空的话则不获取返回值。调用pthread_join之后，调用线程将处于阻塞状态，直到指定的线程调用pthread_exit、从启动例程中返回或者被取消。如果线程被取消，rval_ptr指定的内存单元就被置为PTHREAD_CALCELED。
3. 如果线程处于分离状态，那么pthread_join的调用就会失败，返回EINVAL。
4. pthread_create产生的新线程和调用pthread_exit的线程必须保证线程结束后rval_ptr指向的地址是有效的，否则其他线程在使用其返回值的时候可能会有问题。

**3) pthread_cancel**

```C
int pthread_cancel(pthread_t tid);
```
1. 此函数用于请求取消同一进程的其他线程。
2. 返回值：若成功，返回0；若失败，返回错误编号。
3. pthread_cancel会使标识为tid的线程行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit函数。但是线程可以选择忽略或者控制如何被取消。
4. pthread_cancel并不等待线程终止，它仅仅提出请求。

**4) pthread_cleanup_push和pthread_cleanup_pop**

```C
void pthread_cleanup_push(void (*rtn)(void*), void* arg);
void pthread_cleanup_pop(int execute);
```

1. 与atexit函数类似，pthread_cleanup_push用于注册线程清理函数，最后线程清理函数的调用顺序和注册顺序相反。
2. 当线程执行以下动作时，将执行线程清理函数：
    1. 调用pthread_exit时。
    2. 响应取消请求时。
    3. 用非零参数调用pthread_cleanup_pop时。
3. 如果execute参数为0，清理函数将不再调用。
4. 上述两个函数有一个限制，由于它们可以实现成宏，因此需要在线程相同的作用域内配对使用。
5. 线程通过return返回的话，是不会调用清理函数的。


**8.5 线程同步**

**1) 概念**

1. 在变量修改时间多于存储器访问周期的处理器架构中，可能会与到存储器读周期和两个写周期交叉的情况。这时候读的数据是有问题的。
2. 两个线程试图在同一时间修改同一个变量时，也需要考虑同步。

**2) 互斥量**




