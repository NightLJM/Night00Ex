## **005.进程控制**

**4.1 进程标识**

1. 进程ID是可复用的，大多数Unix系统采用延时复用算法，使得复用于新进程的ID不同于最近终止的进程
2. ID为0的进程通常是调度进程，通常被称为交换进程
3. ID为1的进程通常是init进程，在自举过程结束时由内核调用。该进程通常要读取与系统有关的初始化文件。该进程是用户进程，但可以超级用户权限执行
4. ID为2的进程是守护进程，负责支持虚拟存储系统的分页操作
5. pid_t getpid(void);返回调用进程的进程ID
6. pid_t getppid(void);返回调用进程的父进程ID
7. uid_t getuid(void);返回进程的实际用ID
8. uid_t geteuid(void);返回进程的有效用户ID
9. gid_t getgid(void);返回调用进程的实际组ID
10. gid_t getegid(void);返回调用进程的有效组ID

**4.1 fork类函数**

**1) fork**

1. pid_t fork(void);
2. 子进程返回0，父进程返回子进程id;若出错，返回-1
3. fork出的子进程会获得父进程数据空间、堆和栈的副本，但现在很多实现并不执行一个父进程数据段、堆和栈的完全副本，而是先以只读的形式使用父进程的，等需要写的时候，在为写的那一块内存制作副本，通常是虚拟内存的一页。
4. 一般而言fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核的进程调度算法。
5. fork的时候，缓冲区的内容子进程也会有一份副本
6. 文件共享：fork出的子进程会复制一份父进程的文件描述符表，但是子进程和父进程对应的描述符指向的是同一个文件表项，即它们共享文件的偏移量。假如子进程和父进程都写同一个文件，而未采取任何同步措施，它们的输出就会混在一起。    
7. fork后处理文件描述有以下两种常见的情况：1）父进程等待子进程完成。这种情况，子进程结束的时候自动更新好了偏移量，父进程无需处理；2）父进程和子进程各自执行不同的程序段。这时父进程和子进程要关闭它们不使用的文件描述符。
8. 父进程和子进程的区别：1）fork返回值不同；2）进程ID不同；3）父进程ID不同；4）子进程tms_utime、tms_utime、tms_cutime、tms_ustime的值设置为0; 5）子进程不继承父进程设置的文件锁；6）子进程未处理的闹钟被清除；7）子进程未处理信号集被设为空集。
9. fork失败的两种场景：1）系统中已有太多进程。2）进程ID不够用。
10. fork的两种用法：1）父进程希望复制自己，使父进程和子进程执行不同代码段；2）一个进程要执行一个不同的程序。通常子进程从fork返回后会立即执行exec。

**2) vfork**

1. vfork和和fork的参数列表和返回值一样。
2. vfork后一般接的是exec
3. vfork和fork类似，也用来创建新进程，但与fork不同的是，vfork出的子进程不会复制父进程的地址空间，而是子进程在父进程的地址空间中运行，这也就说明，vfork的子进程修改数据、进行函数调用、没有调用exec或exit就返回的话，会带来未知的后果、
4. vfork出的子进程会先于父进程执行，在子进程调用exec或exit后，父进程才会执行。如果子进程在调用这两个函数前，需要依赖父进程的下一步动作，就会死锁。
5. vfork函数不应该在可移植的系统中使用。   





