## **012.进程间通信**

**9.1 管道**

``` C
int pipe(int fd[2]);
```
1. 返回值：若成功，返回0；若出错，返回-1；
2. 管道是IPC(进程间通信，InterProcess Communication)的最古老的形式，但有两个局限性：
    1. 标准的管道是半双工(数据只能在一个方向流动)的，虽然某些系统提供了全双工的管道，但为了可移植性，应当不能假定系统提供了全双工管道。
    2. 管道只能在具有两个公共祖先的进程之间使用。一般是管道由一个进程创建，该进程fork子进程后，这两个进程之间就能使用管道了。
3. pipe函数返回两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。fstat函数对管道的每一端都返回一个FIFO类型的文件描述符。可以用S_ISFIFO宏来测试管道。
4. 如果想创建父进程到子进程的管道，可以通过以下步骤：
    1. 父进程创建一个管道，此时管道数据流向：fd[1]->管道->fd[0]。
    2. 父进程fork子进程，此时管道数据流向：fd[1](父进程)与fd[1](子进程)->管道->fd[0](父进程)与fd[0](子进程)。
    3. 关闭父进程中的fd[0]，关闭子进程中的fd[1]。如果是子进程到父进程的管道，则此步骤关闭的文件描述符相反。
5. 当管道的一端关闭后，以下规则起作用：
    1. 若读一个写端关闭的管道：若管道里还有数据，则正常读，所有数据都被读出后，read返回0.
    2. 如果写一个读端关闭的管道：产生信号SIGPIPE，如果忽略该信号或者从信号处理函数处返回，则write返回-1，errno设置EPIPE。
6. 在写管道是，敞亮PIPE_BUF定义了内核管道缓冲大小，如果对管道调用write，且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他线程对管道的写操作交叉；反之可能出现数据交叉的情况。


**9.2 函数popen与pclose**
``` C
FILE* popen(const char* cmdstring, const char* type);
int pclose(FILE* fp);
```
1. popen返回值：若成功，返回文件指针；若出错，返回NULL；
2. pclose返回值：若成功，返回cmdstring终止状态；若出错，返回-1；
3. popen作用：创建一个管道，然后fork一个子进程，子进程调用exec执行cmdstring，并返回一个文件指针。如果type是"r"，则文件指针链接cmdstring的标准输出；如果type是"w"，则文件指针链接cmdstring的标准输入。
4. pclose作用：关闭标准IO流，等待命令终止并返回shell的终止状态。


**9.3 协同进程**

1. 定义：当进程A既产生进程B的输出，又读取进程B的输入，那么进程A就是进程B的协同进程。
2. 协同进程和主进程间可以用管道通信。


**9.4 FIFO**

```C
int mkfifo(const char* path, mode_t mode);
int mkfifoat(int fd, const char* path, mode_t mode);
```
1. 两函数返回值：若成功，返回0；若出错，返回-1。
2. FIFO也被成为命名管道，使用FIFO的两个进程并不需要有关系。FIFO是一种文件结构，通过stat的st_mode成员的编码可以知道文件是否是FIFO尅性。可以用S_ISFIFO宏进行测试。
3. FIFO本质上是个文件，因此mkfifo与mkfifoat类似open和openat。对于mkfifoat，有3中情况：
    1. 若path是绝对路径：则fd参数可以忽略掉。
    2. 若path是相对路径：则fd是一个打开目录的有效文件描述符
    3. 若path是相对路径，且fd为AT_FDCWD：则路径从当前目录开始。
4. 当用mkfifo和mkfifoat创建FIFO时，要用open来打开，open的非阻塞标志(O_NONBLOCK)会产生下列影响：
    1. 若没有指定O_NONBLOCK(一般情况)：只读open要阻塞到某个其他进程为写打开这个FIFO为止，只写open要阻塞到某个其他进程为读打开这个FIFO为止。
    2. 若指定了O_NONBLOCK：只读open立即返回。但若是没有


**9.5 XSI IPC**

**1) 前言**

1. 称为XSI IPC的IPC有三种：消息队列、信号量与共享存储器。
2. 下面先说它们的相同处，之后在分别介绍各自的特点。

**2) 标识符和键**

1. 内核中，IPC(消息队列、信号量或者共享存储器)都用一个非负整数的标识符加以引用。当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，直到达到一个整型数的最大值，然后又转回到0.
2. 标识符是IPC对象的内部名，为了方便在多进程间使用，提供了一个外部命名的方案，即键。无论何时创建一个IPC结构(通过调用msgget、semget或shmget创建)，都应指定一个键。这个键的数据类型就是基本上系统数据类型key_t，通常被定义成长整型。
3. 有多种方法让客户进程和服务器进程在同一个IPC结构上汇聚：
    1. 服务器指定键IPC_PRIVATE创建一个新的IPC结构，返回的标识符放在某处(如文件)中供客户进程使用。指定键为IPC_PRIVATE将保证创建一个新的IPC结构。IPC_PRIVATE键也可以在父子进程，父进程创建新的IPC结构后，返回的标识符可以给fork的子进程使用。接着，子进程又可以将此标识符作为exec函数的一个参数传给新程序。
    2. 可以在一个公用的头文件定义一个客户进程和服务器进程都认可的键。然后服务器进程使用该键创建一个IPC结构，但这可能与一个已有的IPC结构结合，在这种情况下，get函数(msgget、semget、shmget)出错返回。服务器建华更必须处理这一错误，删除已有IPC结构再重新创建它。
    3. 客户进程和服务器进程指定一个的文件名和项目ID，然后调用ftok函数将这两个值变换为一个键，然后通过方法2创建。对于两个文件名不同而项目ID相同的ftok调用，可能会产生相同的键。
```C
key_t ftok(const char* path, int id);   //返回值：若成功，返回键；若出错，返回(key_t)-1.
```
4. msgget、semget、shmget都有两个类似的参数：一个key和一个flag。在创建新的IPC结构时，如果key是IPC_PRIVATE或者和当前某种类型的IPC结构无关，则需要指明flag的IPC_CREATE标志位。当引用一个现有的IPC结构时，key必须为创建时指定的key，且flag不能是IPC_PRIVATE。
5. 绝不能指定key为IPC_PRIVATE来获取一个现有的IPC结构。为了引用一个IPC_PRIVATE创建的IPC，必须知道其标识符，然后在其它IPC调用(msgsnd、msgrcv)中使用该标识符，从而绕过get。
6. 如果希望创建一个新的IPC结构，且要确保没有引用具有同一标识符的现有IPC结构，必须指定flag位的IPC_CREAT和IPC_EXCL标志。这样，若IPC已存在，就会出错，返回EEXIST。

**3) 权限结构**

```C
struct ipc_perm
{
    uid_t uid;
    gid_t gid;
    uid_t cuid;
    gid_t cgid;
    mode_t mode;
    ...
}
```
1. XSI IPC为每一个IPC结构关联了一个ipc_perm。该结构规定了权限和所有者，至少包含以上结构。
2. 创建IPC时，对所有字段赋初值。以后，调用msgctl、semctl、shmctl修改uid、gid和mode字段。为了修改这些值，调用进程必须是IPC结构的创建者或者超级用户。
3. mode规定了消息队列和共享存储的“读”和“写”，规定了信号量的“读”和“更改”。具体如下：
    1. 0400：用户读
    2. 0200：用户写(更改)
    3. 0040：组读
    4. 0020：组写(更改)
    5. 0004：其他读
    6. 0002：其他写(更改)

**4) 缺点**

1. IPC结构是在系统范围内起作用的，没有引用计数。例如：如果一个进程创建了一个消息队列，并在消息队列里放了几则消息，然后进程终止，那么消息队列及其内容不会被删除。它们会一直留在系统中，直到发生下列几个动作为止：
    1. 由某个进程调用msgrcv或者msgctl读消息或者删除消息队列。
    2. 某进程执行ipcrm命令删除消息队列。
    3. 正在自举的系统删除消息队列。
2. IPC结构在文件系统中没有名字，为了支持这些IPC对象，内核增加了十几个全新的系统调用(msgget、semop、shmat等)。不能使用ls和rm来查看和删除IPC对象，为此，增加了两个新命令：ipcs和ipcrm。
3. 为了避免使用键和调用msgget，客户进程总要以某种方式获得服务器的标识符。而该标识符是动态生成的，正如之前说的，服务器进程要讲分配到的IPC的标识符写到一个文件中以便客户程序读取。

**5) 优点**

1. 可靠：所有形式的IPC都被限制在一台主机上，因此是可靠的。若是消息通过网络传输时，需要考虑丢失消息的可能性。
2. 流控制：如果系统资源(缓冲区)缺失，或者如果接收进程不能再接收更多的消息，则发送进程就要休眠。当流控制条件消失时，发送进程被自动唤醒。


**6) 消息队列**




 