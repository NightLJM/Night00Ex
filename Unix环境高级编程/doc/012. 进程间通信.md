## **012.进程间通信**

**12.1 管道**

``` C
int pipe(int fd[2]);
```
1. 返回值：若成功，返回0；若出错，返回-1；
2. 管道是IPC(进程间通信，InterProcess Communication)的最古老的形式，但有两个局限性：
    1. 标准的管道是半双工(数据只能在一个方向流动)的，虽然某些系统提供了全双工的管道，但为了可移植性，应当不能假定系统提供了全双工管道。
    2. 管道只能在具有两个公共祖先的进程之间使用。一般是管道由一个进程创建，该进程fork子进程后，这两个进程之间就能使用管道了。
3. pipe函数返回两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。fstat函数对管道的每一端都返回一个FIFO类型的文件描述符。可以用S_ISFIFO宏来测试管道。
4. 如果想创建父进程到子进程的管道，可以通过以下步骤：
    1. 父进程创建一个管道，此时管道数据流向：fd[1]->管道->fd[0]。
    2. 父进程fork子进程，此时管道数据流向：fd[1](父进程)与fd[1](子进程)->管道->fd[0](父进程)与fd[0](子进程)。
    3. 关闭父进程中的fd[0]，关闭子进程中的fd[1]。如果是子进程到父进程的管道，则此步骤关闭的文件描述符相反。
5. 当管道的一端关闭后，以下规则起作用：
    1. 若读一个写端关闭的管道：若管道里还有数据，则正常读，所有数据都被读出后，read返回0.
    2. 如果写一个读端关闭的管道：产生信号SIGPIPE，如果忽略该信号或者从信号处理函数处返回，则write返回-1，errno设置EPIPE。
6. 在写管道是，敞亮PIPE_BUF定义了内核管道缓冲大小，如果对管道调用write，且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他线程对管道的写操作交叉；反之可能出现数据交叉的情况。


**12.2 函数popen与pclose**
``` C
FILE* popen(const char* cmdstring, const char* type);
int pclose(FILE* fp);
```
1. popen返回值：若成功，返回文件指针；若出错，返回NULL；
2. pclose返回值：若成功，返回cmdstring终止状态；若出错，返回-1；
3. popen作用：创建一个管道，然后fork一个子进程，子进程调用exec执行cmdstring，并返回一个文件指针。如果type是"r"，则文件指针链接cmdstring的标准输出；如果type是"w"，则文件指针链接cmdstring的标准输入。
4. pclose作用：关闭标准IO流，等待命令终止并返回shell的终止状态。


**12.3 协同进程**

1. 定义：当进程A既产生进程B的输出，又读取进程B的输入，那么进程A就是进程B的协同进程。
2. 协同进程和主进程间可以用管道通信。


**12.4 FIFO**

```C
int mkfifo(const char* path, mode_t mode);
int mkfifoat(int fd, const char* path, mode_t mode);
```
1. 两函数返回值：若成功，返回0；若出错，返回-1。
2. FIFO也被成为命名管道，使用FIFO的两个进程并不需要有关系。FIFO是一种文件结构，通过stat的st_mode成员的编码可以知道文件是否是FIFO。可以用S_ISFIFO宏进行测试。
3. FIFO本质上是个文件，因此mkfifo与mkfifoat类似open和openat。对于mkfifoat，有3中情况：
    1. 若path是绝对路径：则fd参数可以忽略掉。
    2. 若path是相对路径：则fd是一个打开目录的有效文件描述符
    3. 若path是相对路径，且fd为AT_FDCWD：则路径从当前目录开始。
4. 当用mkfifo和mkfifoat创建FIFO时，要用open来打开，open的非阻塞标志(O_NONBLOCK)会产生下列影响：
    1. 若没有指定O_NONBLOCK(一般情况)：只读open要阻塞到某个其他进程为写打开这个FIFO为止，只写open要阻塞到某个其他进程为读打开这个FIFO为止。
    2. 若指定了O_NONBLOCK：只读open立即返回。但若是没有


**12.5 XSI IPC**

**1) 前言**

1. 称为XSI IPC的IPC有三种：消息队列、信号量与共享存储器。
2. 下面先说它们的相同处，之后在分别介绍各自的特点。

**2) 标识符和键**

1. 内核中，IPC(消息队列、信号量或者共享存储器)都用一个非负整数的标识符加以引用。当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，直到达到一个整型数的最大值，然后又转回到0.
2. 标识符是IPC对象的内部名，为了方便在多进程间使用，提供了一个外部命名的方案，即键。无论何时创建一个IPC结构(通过调用msgget、semget或shmget创建)，都应指定一个键。这个键的数据类型就是基本上系统数据类型key_t，通常被定义成长整型。
3. 有多种方法让客户进程和服务器进程在同一个IPC结构上汇聚：
    1. 服务器指定键IPC_PRIVATE创建一个新的IPC结构，返回的标识符放在某处(如文件)中供客户进程使用。指定键为IPC_PRIVATE将保证创建一个新的IPC结构。IPC_PRIVATE键也可以在父子进程，父进程创建新的IPC结构后，返回的标识符可以给fork的子进程使用。接着，子进程又可以将此标识符作为exec函数的一个参数传给新程序。
    2. 可以在一个公用的头文件定义一个客户进程和服务器进程都认可的键。然后服务器进程使用该键创建一个IPC结构，但这可能与一个已有的IPC结构结合，在这种情况下，get函数(msgget、semget、shmget)出错返回。服务器建华更必须处理这一错误，删除已有IPC结构再重新创建它。
    3. 客户进程和服务器进程指定一个的文件名和项目ID，然后调用ftok函数将这两个值变换为一个键，然后通过方法2创建。对于两个文件名不同而项目ID相同的ftok调用，可能会产生相同的键。
```C
key_t ftok(const char* path, int id);   //返回值：若成功，返回键；若出错，返回(key_t)-1.
```
4. msgget、semget、shmget都有两个类似的参数：一个key和一个flag。在创建新的IPC结构时，如果key是IPC_PRIVATE或者和当前某种类型的IPC结构无关，则需要指明flag的IPC_CREATE标志位。当引用一个现有的IPC结构时，key必须为创建时指定的key，且flag不能是IPC_PRIVATE。
5. 绝不能指定key为IPC_PRIVATE来获取一个现有的IPC结构。为了引用一个IPC_PRIVATE创建的IPC，必须知道其标识符，然后在其它IPC调用(msgsnd、msgrcv)中使用该标识符，从而绕过get。
6. 如果希望创建一个新的IPC结构，且要确保没有引用具有同一标识符的现有IPC结构，必须指定flag位的IPC_CREAT和IPC_EXCL标志。这样，若IPC已存在，就会出错，返回EEXIST。

**3) 权限结构**

```C
struct ipc_perm
{
    uid_t uid;
    gid_t gid;
    uid_t cuid;
    gid_t cgid;
    mode_t mode;
    ...
}
```
1. XSI IPC为每一个IPC结构关联了一个ipc_perm。该结构规定了权限和所有者，至少包含以上结构。
2. 创建IPC时，对所有字段赋初值。以后，调用msgctl、semctl、shmctl修改uid、gid和mode字段。为了修改这些值，调用进程必须是IPC结构的创建者或者超级用户。
3. mode规定了消息队列和共享存储的“读”和“写”，规定了信号量的“读”和“更改”。具体如下：
    1. 0400：用户读
    2. 0200：用户写(更改)
    3. 0040：组读
    4. 0020：组写(更改)
    5. 0004：其他读
    6. 0002：其他写(更改)

**4) 缺点**

1. IPC结构是在系统范围内起作用的，没有引用计数。例如：如果一个进程创建了一个消息队列，并在消息队列里放了几则消息，然后进程终止，那么消息队列及其内容不会被删除。它们会一直留在系统中，直到发生下列几个动作为止：
    1. 由某个进程调用msgrcv或者msgctl读消息或者删除消息队列。
    2. 某进程执行ipcrm命令删除消息队列。
    3. 正在自举的系统删除消息队列。
2. IPC结构在文件系统中没有名字，为了支持这些IPC对象，内核增加了十几个全新的系统调用(msgget、semop、shmat等)。不能使用ls和rm来查看和删除IPC对象，为此，增加了两个新命令：ipcs和ipcrm。
3. 为了避免使用键和调用msgget，客户进程总要以某种方式获得服务器的标识符。而该标识符是动态生成的，正如之前说的，服务器进程要讲分配到的IPC的标识符写到一个文件中以便客户程序读取。

**5) 优点**

1. 可靠：所有形式的IPC都被限制在一台主机上，因此是可靠的。若是消息通过网络传输时，需要考虑丢失消息的可能性。
2. 流控制：如果系统资源(缓冲区)缺失，或者如果接收进程不能再接收更多的消息，则发送进程就要休眠。当流控制条件消失时，发送进程被自动唤醒。


**6) 消息队列**

``` C
int msgget(key_t key, int flag);
int msgctl(int msqid, int cmd, struct msqui_ds* buf);
int msgsnd(int msqid, const void* ptr, size_t nbytes, int flags);
ssize_t msgrcv(int msqid, void* ptr, size_t nbytes, long type, int flag);
```
1. msgget：
    1. 返回值：若成功，返回消息队列id；若出错，返回-1.
    2. 作用：打开一个现有的消息队列或者创建一个新消息队列。
    3. msgget创建一个新消息队列的时候会初始化消息队列的msqid_ds结构。
2. msgctl的返回值：若成功，返回0；若出错，返回-1。其作用根据cmd决定：
    1. IPC_STAT：取队列的msqid_ds结构，并将其存放在buf指向的结构中。
    2. IPC_SET：将字段msg_perm.uid、msg_perm.gid、msg_perm.mode和msg_qbytes从buf指向的结构复制到这个队列相关的msqid_ds结构中。此命令只能由两种进程执行：一种是有效用户ID等于msg_perm.cuid或msg_perm.uid；另一种是具有超级用户权限的进程。只有超级用户才能增加msg_qbytes的值。
    3. IPC_RMID：从系统中删除该消息队列以及还在消息队列中的数据，这种删除立即生效，仍在使用该消息队列的进程在它们下次试图对消息队列进行操作时，将发生EIDRM的错误。此命令只能由两种进程执行：一种是有效用户ID等于msg_perm.cuid或msg_perm.uid；另一种是具有超级用户权限的进程。
3. msgsnd的返回值：若成功，返回0；若出错，返回-1。用于将消息放入消息队列。
    1. nbytes是实际发送的数据大小。
    2. flag若指定为IPC_NOWAIT，则消息队列满的时候立即出错返回EAGAIN。若没有指定IPC_NOWAIT，则消息队列满时，要发送消息的进程一直阻塞到：有空间容纳新消息；或从系统中删除此消息队列；或捕捉到一个信号，并从信号处理函数返回。第二种情况会返回EIDRM错误。最后一种情况返回EINTR错误。
    3. ptr参数指向一个结构体。结构体包含一个长整数类型和实际发送的数据。若发送512字节的，可定义下列结构。
``` C
struct mymsg{
    long mtype;                 //消息的类型，正长整数
    char mtext[512];            //实际的数据
};
```
4. msgrcv返回值：若成功，返回消息数据部分长度，若出错，返回-1。作用是从消息队列拿消息。
    1. ptr的结构与msgsnd一样。这里是接收到的。
    2. nbytes是实际数据的缓冲区长度。若实际数据长度大于nbytes：若flag设置了MSG_NOERROR位，则消息被阶段，并且无提示；若设置了，则出错返回E2BIG。
    3. type用于过滤消息：若type == 0，则接收队列的第一条消息；若type > 0，则接收消息类型为type的第一个消息；若type < 0，则接收消息类型小于绝对值type的消息，若此类消息有多个，则取类型值最小的。
    4. flag可以设置IPC_NOWAIT位：若消息队列没有消息时，则返回-1，errno置为ENOMSG。繁殖进程一直阻塞到：消息队列中有消息；或从系统中删除此消息队列；或捕捉到一个信号，并从信号处理函数返回。第二种情况errno置为EIDRM；第三种情况errno置为EINTR。
5. 消息队列、FIFO、Unix域套接字的比较：效率上差不多，但考虑到消息队列的问题，应该尽量少用它们。


**7) 信号量**

1. 信号量是一个计数器，进程为了获取信号量相关联的共享资源，需要进行一下操作：
    1. 测试控制该信号量。
    2. 若信号量值为正，则进程可以获取该资源，与此同时信号量的值减一。
    3. 若信号量不为正，则进程进入休眠直到信号量的值大于0，此时进程被唤醒重新执行步骤1。
2. XSI的信号量比常用的信号量要复杂，原因如下：
    1. 信号量并非单个非负值，而是必须定义为含有一个或多个信号量值的集合。
    2. 信号量的创建(semget)和初始化(semctl)是分开的，因此无法原子地创建一个信号量集合，并对该信号量集合赋初值。
    3. 即使没有进程正在使用各种形式的XSI IPC，它们也是存在的，有的程序可能终止的时候并没有释放分配给它的信号量。
3. 信号量与记录锁、互斥量的比较：
    1. 就效率而言：互斥量优于记录锁优于信号量
    2. 若不特别考虑效率的话，可以优先使用记录锁。因为占用记录锁的进程终止时，系统会自动管理遗留下来的记录锁，而互斥量和信号量都不会。

**78) 共享存储**

1. XSI共享存储和内存映射的文件的区别在于，前者没相关的文件，XSI共享存储段是内存的匿名段。


**12.5 POSIX 信号量**

```  C
sem_t* sem_open(const char* name, int flag, ... /*mode_t mode, unsigned int value*/);
int sem_close(sem_t* sem);
int sem_unlink(coanst char* name);
int sem_trywait(sem_t* sem);
int sem_wait(sem_t* sem);
int sem_timedwait(sem_t* restrict sem, const struct timespec* restrict tsptr);
int sem_post(sem_t* sem);
int sem_init(sem_t* sem);
int sem_destory(sem_t* sem);
int sem_getvalue(sem_t* restrict sem, int* restrict valp);
```
1. POSIX信号量和XSI信号量的区别：
    1. POSIX的实现更高性能
    2. POSIX使用的接口较为简单，没有信号量集
    3. POSIX信号量维持了一个引用计数，要是删除该信号量，则该信号量会一直工作到最后一个引用释放。而删除XSI信号量则是立即执行，删除后，进程对该信号量的操作会失败。
2. POSIX信号量有两种：命名和非命名的。两者的差别在创建和销毁。未命名的信号量存在内存，因此能使用它的进程必须要能访问这块内存，若这块内存被映射到多个进程空间，则可被多个进程使用。命名的信号量可以通过名字访问，因此可以被任何知道它名字的进程或线程访问。
3. sem_open用来创建一个新的命名信号量或使用一个现有信号量。其返回值：若成功，返回指向信号量的指针；若出错，返回SEM_FAILED。：
    1. 当使用一个现有的信号量时，只需要指定两个参数：信号量名字name和flag的0值。
    2. flag有O_CREAT标志时，若命名的信号量不存在，则创建一个新的。如果已经存在，则会被使用，不会发生别的。
    3. 若flag指定O_CREAT标志，需要提供两个额外参数，mode和value。mode指定谁可以访问信号量，与打开文件的权限位相同，该权限为也可以被调用者的文件创建屏蔽字修改。权限位只有读和写需要注意。若打开一个现有的信号量，则不允许指定权限位。
    4. value参数指定信号量初始值。范围在0~SEM_VALUE_MAX
    5. 为了增加可移植性，需要遵守以下规则：1)名字的第一个字符是'/'，除此之外不能有其他'/'。因为大多信号量的实现是使用文件系统。2)信号量的名字长度不用超过_POSIX_NAME_MAX，这是文件系统允许的最大名字限制。
4. 命名信号量操作完成时，可以调用sem_close释放命名的信号量的资源（信号量引用-1）。若没有调用sem_close进程就退出了，内核会自动关闭信号量，但这并不会影响信号量的值，即如果对其进行了+1操作，则内核关闭信号量的时候并不会对其进行-1操作。
5. sem_unlink用于删除该信号量的名字。如果没有进程引用该信号量，则该信号量被销毁，否则，销毁将延迟到最后一个引用关闭。
6. sem_wait和sem_trywait和sem_timedwait对信号量实行-1操作。
7. sem_post对信号量执行+1操作。
8. sem_init用于初始化未命名信号量，sem_destory用于销毁未命名信号量。
12. sem_getvalue用于获得信号量值。



 