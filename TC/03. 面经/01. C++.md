## **001. 进程几种通讯的比较**

进程通信的方式主要有：管道、FIFO、信号量、消息队列、共享内存和套接字。

1. 管道是一种只能用在共同祖先的进程之间的通信方式，然后根据它数据的流动方向又分为半双工和全双工的。有的系统可能并不会实现全双工的管道，因此，如果要考虑程序在不同的系统的一致性的话，应当按照半双工来使用管道。管道使用的流程一般是：父进程先创建管道，然后fork子进程，然后父进程分别关闭管道没有使用的一端。另外，如果子进程的标准输入和标准输出均来自父进程，那子进程就是父进程的协程。
2. FIFO又称为命名管道，它没有管道的那种共同祖先的限制。就理解来说的话，可以把FIFO理解成用于两个进程之间沟通的文件，除了创建，读写的流程基本都一样。但与普通文件不同的是，数据通过FIFO的时候都是走内存的，普通文件的话可能是设计磁盘操作。而且FIFO还有一些用于通信的特征：比如只有写进程没有读进程的话会产生SIGPIPE的信号。
3. 信号量、消息队列、共享内存又分为SystemV和Posix两套。SystemV的用起来比较麻烦，Posix的用起来方便些。信号量可以理解为资源的数量，也算一种同步机制，初始化的时候会给它赋这么一个初始值。当某个进程获取这个信号量的时候，如果这个信号量的值大于0，那就可以获取成功，并且这个值减1。如果等于0的话，就根据进程是直接wait还是trywait或者是timedwait来有不同的行为，总之就是资源没获取成功。进程释放资源的时候这个资源数就会加一。Posix信号量有一个引用计数，如果要删除这个信号量的话，这个信号量会一直存在到最后一个进程不使用它。
4. 消息队列其实就是消息的链表。这个链表的节点有两个内容，消息类型和具体的数据。进程放数据的话就直接往里面塞，拿数据的话，可以拿队列的第一个，也可以拿某种类型的数据的第一个，也可以拿类型小于某个值的第一个。这里的类型是一个长整型。
5. 共享内存就是把同一块内存区域映射到不同进程的地址空间。因为是同一块空间，也就设计到同步问题，一般和其他用于同步的技术一起使用，如信号量之类的。
6. 最后是套接字，因为它支持不同机器间的通信，因此基本上都用在网络编程中。
7. 这些通信方式里面最快的就是共享内存。

## **002. malloc和new的细节**

1. 首先malloc和new分别是C和C++里面的函数，它们都被用来分配堆上的内。
2. 先说malloc吧：
    1. 使用malloc的时候告诉它一个，它返回一个指向堆上空间的指针，这个空间的大小就是传进的字节数。如果分配失败的话，它直接返回空指针。刚分配还没使用的话，malloc只是要了一块虚拟内存的空间，这时候还没映射到物理内存，当实际使用的时候，会触发缺页，然后映射到物理内存。
    2. malloc返回的的指针是个空指针类型，也就是说不涉及到数据类型，因此真正使用的时候要将这个指针转一遍。而且，malloc分配的内存不涉及到对象的初始化，要初始化对象的话，用calloc，要重新指定一个已经分配的内存的大小的话用realloc。
    3. malloc和free配套使用。
3. 然后是new：
    1. new传入的是类构造函数指定的参数，然后它返回一个这个对象的指针，这个对象也是堆上的。如果new失败的话，会抛bad_alloc的异常。
    2. new因为返回的是对象的指针，因此涉及到两步。第一步是调用operate new，operate new是C++的一个函数，可以重载，我们说的new是一个操作符，没有重载的说法。但是，operate new太底层了，很少有重载的需求。new的第二步就是调用对象的构造函数初始化对象。
    3. new和delete配套使用，如果new返回的是一个数组指针的话，delete也要用方括号的那种形式，因为malloc是直接返回原生空指针，所以也就没这说法。

## **003. 父进程使用malloc得到一块内存，子进程可以使用吗**

1. 首先父进程malloc了一块内存，子进程中相应的也有一块内存，刚fork的时候，这两个内存是一样的，但只要有一个进程往这个内存里写数据，它们的物理内存就会不同。具体的原因得看fork的机制：
    1. 父进程fork子进程的时候，子进程会从父进程那里复制一份页表。也就是说，这个时候父子进程有一样的数据段、代码段和堆栈段，虚拟地址是一样的，虚拟地址映射的物理地址也是一样的。
    2. 因为父子进程共享了物理页面，因此内核会把它标记成已读，这个时候父子进程都无法对它修改，要是修改的话，就会产生一个错误，然后内核给这个进程这次修改的页映射一个新的物理页，这也就是写时复制技术。之所以有这个技术还是因为fork后经常接exec，exec会清除原有的堆栈和父进程共享空间，为了效率考虑。
    3. 所以，当实际往这块内存写的时候，物理地址会变成两块。


## **004. C++类内存对齐**

0. 为什么要内存对齐
    1. 首先，字节对齐指的是是变量在内存的地址一般是某个值的倍数，这个值通常是4或8。CPU去取内存的数据一般按照双字节、四字节、八字节、十六字节乃至三十二字节存取数据。为了提高存取效率，C/C++就有了一个对齐规则。

1. 对齐原则：
    0. 每个特定平台的编译器都有自己的对齐系数，编译系数可以通过#pragma pack(n)来设置，这里的n就是想要设置的对齐系数
    1. 结构体变量的首地址能被其最宽的基本类型成员的大小整除
    2. 结构体第一个数据成员存放在offset为0的地方，之后每个成员的偏移量都是min(对齐系数, 该成员大小)的最小倍数。
    3. 结构体的总大小时min(对齐系数, 最宽基本类型成员大小)的最小倍数。

2. 基本数据类型大小：char(1, 1), short int(2, 2), int(4, 4), long int(4, 8), long long int(8, 8), 指针(4, 8)， float(4, 4), double(8, 8)。左边时32位系统，右边64位系统、


## **005. C++程序内存分布**

1. 一个C或C++程序由五部分组成，从低地址端到高地址段分别是：正文段、初始化数据端(数据段)、未初始化数据段(BSS段)、堆段、栈段。
  1. 正文段：也叫代码段，CPU执行的机器指令部分，可共享的，所以即使是频繁执行的程序在存储器中也只需要一个正文副本；正文通常是只读的
  2. 初始化数据段：通常称这段为数据段，它包含了程序中需要明确赋予初值的变量。如在所有函数外的声明：int max = 99; static变量等
  3. 未初始化数据段：通常称这段为bss段，程序开始执行前，bss段里的数据会被初始化为0或空指针；如在所有函数外的声明：int sum[100];
  4. 堆段：动态分配的内存都在这里，从低地址端往高地址端扩充
  5. 栈段：保存调用函数的地址与临时变量的地址，从低地址端往高地址端扩充。
2. 另外，C++标准没有规定虚函数表的实现，但考虑到所有类共用一个，应该是放在数据段。


## **006. 构造函数和析构函数能否为虚函数，构造函数为虚函数有什么后果**

1. 首先构造函数不能为虚函数，声明为虚函数的话，其实和没声明一样，不仅如此，甚至还会报编译错误，虽然这个错误可以强制改成编译警告，构造函数里面调用虚函数的话，也访问不到子类的函数，最多访问到自己。至于析构函数，一个类要是写出来可能会有人继承的话，析构函数一定得写成需的。
2. 构造函数为什么不能为虚函数，这涉及到两方面的东西。一个是虚函数指针，另一个是类构造的顺序。
    1. 每个有虚函数的类都维护这一张虚函数表，这张表里记录这这些虚函数的实际调用地址，然后在每个类对象中，都有一个虚函数指针，这个指针指向虚函数表，所有虚函数调用都是通过这个虚函数指针来找地址的。虚函数指针一般放在类所有成员的最前面。
    2. 构造一个类，会经历几个步骤：
        - 按继承顺序构造基类，基类构造顺序与声明列表中的顺序无关。
        - 安成员定义顺序构造成员，这个顺序同样与声明列表中的无关。
        - 执行自身构造函数。
3. 构造函数如果可以写成虚的，或者调用虚函数，那么这个虚函数起作用也是在基类的构造过程中，而这个时候子类的虚函数指针还没构造出来。无法访问虚函数表。


## **007. 智能指针**

1. 智能指针分三种,但不管哪种智能指针，尽量不要让智能指针和裸指针混用：
    1. shared_ptr: 内部维持一个引用计数，当一个托付给shared_ptr的对象没有shared_ptr指向时，该对象被释放。
    2. unique_ptr： 一个托付给unique_ptr的对象只能有一个unique_ptr指向。
    3. weak_ptr：weak_ptr可以用来指向一个shared_ptr管理的对象，且不影响其引用计数。

## **007. 用宏定义函数指针**

```C
#define 
```
















